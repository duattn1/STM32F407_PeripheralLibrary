#include <Windows.h>
#include <stdio.h>
#include <stdint.h>
#include "../inc/serial_port_communication.h"
#include "../inc/hex_parser.h"

#define ACK							0x79
#define NACK						0x1F
#define BINARY_REQUEST				0x01

void printCMDMenu(void);

void sendImageData(void);

/* Here is the hex file of Blue LED Blinking application */
uint8_t hexBinary[] = 
":020000040801F1\
:1000000068060020290201083102010833020108B4\
:10001000350201083702010839020108000000001A\
:100020000000000000000000000000003B0201088A\
:100030003D020108000000003F02010855040108CC\
:100040004302010843020108430201084302010878\
:100050004302010843020108430201084302010868\
:100060004302010843020108430201084302010858\
:100070004302010843020108430201084302010848\
:100080004302010843020108430201084302010838\
:100090004302010843020108430201084302010828\
:1000A0004302010843020108430201084302010818\
:1000B0004302010843020108430201084302010808\
:1000C00043020108430201084302010843020108F8\
:1000D00043020108430201084302010843020108E8\
:1000E00043020108430201084302010843020108D8\
:1000F00043020108430201084302010843020108C8\
:1001000043020108430201084302010843020108B7\
:1001100043020108430201084302010843020108A7\
:100120004302010843020108430201084302010897\
:100130004302010843020108430201084302010887\
:100140004302010843020108430201084302010877\
:100150004302010843020108430201084302010867\
:100160004302010843020108430201084302010857\
:100170004302010843020108430201080000000095\
:10018000430201084302010800F002F800F03CF8C5\
:100190000AA090E8000C82448344AAF10107DA45E2\
:1001A00001D100F031F8AFF2090EBAE80F0013F0F8\
:1001B000010F18BFFB1A43F001031847E8030000C2\
:1001C00008040000103A24BF78C878C1FAD8520752\
:1001D00024BF30C830C144BF04680C6070470000C1\
:1001E0000023002400250026103A28BF78C1FBD840\
:1001F000520728BF30C148BF0B6070471FB500F0E1\
:10020000CBF91FBD10B510BD00F031F81146FFF756\
:10021000F5FF00F069F900F04FF803B4FFF7F2FFC3\
:1002200003BC00F057F80000094880470948004720\
:10023000FEE7FEE7FEE7FEE7FEE7FEE7FEE7FEE796\
:10024000FEE7FEE704480549054A064B70470000F3\
:100250006D0401088901010868000020680600207B\
:10026000680200206802002070477047704775469A\
:1002700000F02CF8AE4605006946534620F0070012\
:10028000854618B020B5FFF7DDFFBDE820404FF0F0\
:1002900000064FF000074FF000084FF0000B21F070\
:1002A0000701AC46ACE8C009ACE8C009ACE8C0093D\
:1002B000ACE8C0098D46704710B50446AFF3008026\
:1002C0002046BDE81040FFF7A8BF00000048704777\
:1002D0000800002001491820ABBEFEE726000200FE\
:1002E000704700002DE9F041DDE90656089C4C4FAF\
:1002F000B84208D14B4F3F6847F00107DFF824C1EF\
:10030000CCF8007022E0484FB84208D1454F3F6812\
:1003100047F00207DFF80CC1CCF8007016E0434F3D\
:10032000B84208D13F4F3F6847F00407DFF8F4C0F8\
:10033000CCF800700AE03E4FB84207D1394F3F6811\
:1003400047F00807DFF8DCC0CCF8007007684FEA18\
:1003500041084FF0030C0CFA08FC27EA0C07076071\
:1003600007684FEA410C02FA0CFC47EA0C070760E9\
:10037000476803FA01FC47EA0C07476087684FEAC1\
:1003800041084FF0030C0CFA08FC27EA0C078760C1\
:1003900087684FEA410C05FA0CFC47EA0C078760B6\
:1003A000C7684FEA41084FF0030C0CFA08FC27EA33\
:1003B0000C07C760C7684FEA410C06FA0CFC47EA15\
:1003C0000C07C760082912DA076A4FEA81084FF064\
:1003D0000F0C0CFA08FC27EA0C070762076A4FEAC1\
:1003E000810C04FA0CFC47EA0C07076215E0476A27\
:1003F0004FEA810CACF1200C4FF00F0808FA0CF812\
:1004000027EA08074762476A4FEA810CACF1200CE3\
:1004100004FA0CFC47EA0C074762BDE8F0810000D3\
:100420000000024030380240000402400008024050\
:10043000000C024010B5826901F1100301249C40B8\
:100440002243826110BD826901238B401A4382617D\
:10045000704700000448006820B103480068401E4F\
:10046000014908607047000000000020144800683F\
:1004700040F47000124908601248006840F0010022\
:100480001049086000200F49083108600D480068D5\
:100490000D4908400B4908600C48091D0860081FF9\
:1004A000006820F48020091F0860002005490C31F5\
:1004B00008604FF000600249803908607047000012\
:1004C00088ED00E000380240FFFFF6FE1030002407\
:1004D00001B504490098086000BF02480068002880\
:1004E000FBD108BD000000200EB526482649086053\
:1004F00062B600200322CDE90020034601220F212D\
:1005000002902248FFF7EEFE0F212048FFF79BFFE5\
:100510001F4800684FF47A72B0FBF2F1481EB0F148\
:10052000807F00D31CE0481E4FF0E022506150173E\
:100530000F22002804DB13071C0E164B1C5407E087\
:1005400013071D0E104B103300F00F04241F1D5510\
:1005500000BF00204FF0E02290610720106100BF33\
:100560000FE00F210948FFF76EFF4FF47A70FFF795\
:10057000AFFF0F210548FFF75DFF4FF47A70FFF7DB\
:10058000A7FFEEE70000010808ED00E0000C0240C4\
:100590000400002000E400E04FF04070E1EE100A9B\
:1005A00070470000C405010800000020080000009A\
:1005B000C4010108CC050108080000206006000005\
:0C05C000E0010108000000000024F4002D\
:040000050801018964\
:00000001FF";
	
void main(void){
	uint8_t receivedRequest = 0;
	
	serialPortInit();	

	Sleep(1000);
	
	while(1){
		receivedRequest = receiveByte();
		if( receivedRequest == BINARY_REQUEST){
			sendImageData();
		}		
	}		
	
	CloseHandle(hComm); /*Closing the Serial Port*/
	
	/*programFlash();*/
	

	_getch();
} 
	
void sendImageData(void){
	uint32_t readIndex = 0;    
    uint16_t baseAddress = 0;
    uint8_t i;
    
	while(readIndex < sizeof(hexBinary)){
		while(hexBinary[readIndex] != ':' && readIndex < sizeof(hexBinary)){
   			readIndex++;
  		}
  		printf("----------\n");
  		if(hexBinary[readIndex] == ':'){
  			hexRecord hRecord;  
			uint8_t ackValue = 0;  			
  			hRecord = readHexRecord(hexBinary, readIndex);
  			int i;
  			do {
  				/* The order of sending each hex record infor to the STM32F4 board*
  				printf("Sending: %02x, %04x, %02x, %02x |", hRecord.length, hRecord.offset, hRecord.type, hRecord.checksum);
  				for(i = 0; i < hRecord.length; i++){
  					printf(" %02x,", hRecord.data[i]);  					
				  }*/
  				sendByte(hRecord.length);
  				
  				uint8_t offset1stByte = (hRecord.offset & 0xFF00) >> 8;
  				uint8_t offset2ndByte = (hRecord.offset & 0x00FF) >> 0; 
  				
  				sendByte(offset1stByte);
  				sendByte(offset2ndByte);
  				sendByte(hRecord.type);
  				for(i = 0; i < hRecord.length; i++){
  					sendByte(hRecord.data[i]);  			
				}
				sendByte(hRecord.checksum);	
				
				/* Wait for ACK byte from STM32F4 after sending record data*/
				ackValue = receiveByte();
				printf("- %02x, %02x  | ack = %x\n", offset1stByte, offset2ndByte, ackValue);
				Sleep(100);
			} while (ackValue != ACK);
  			
  			/*
			if(hRecord.type == 4){
  				baseAddress |= hRecord.data[0] << 8;	
				baseAddress |= hRecord.data[1] ;		
			} else if (hRecord.type == 0){
				printf("------address: %08x-------\n", hRecord.address + baseAddress);
  				writeMemory(hRecord);
			} */
			/* Not process the other type of record yet*/
  			
  			/*
  			uint8_t j;
  			printf(":%02x ", hRecord.length);
			printf("%04x ", hRecord.address);
			printf("%02x ", hRecord.type);   
			for(j = 0; j < hRecord.length ;j++){
				printf("%02x", hRecord.data[j]);
			}   
			printf(" %02x\n", hRecord.checksum); */
			
		}			
		
		readIndex++;	
	}
	
}
		

